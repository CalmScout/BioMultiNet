# CmmD: Continual Multiplex network Module Detector


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

Python implementation of the algorithm originally proposed in [“The
multilayer community structure of medulloblastoma” by Iker
Núñez-Carpintero et.
al.](https://www.sciencedirect.com/science/article/pii/S2589004221003333).

Implementation relies on
[MolTi-DREAM](https://github.com/gilles-didier/MolTi-DREAM) for
communities detection problem.

- Make sure to add molti-console as an executable program from any
  directory by adding it to your ~/.bashrc file. (This file may change
  depending on your OS ditribution)

## 0. Import libraries and define paths

Auxiliary function to measure the execution time:

------------------------------------------------------------------------

### time_it

>      time_it (func)

## 1. Define function for community detection

------------------------------------------------------------------------

### communities_detection

>      communities_detection (input_layers:list[str]=None, gamma_min:float=None,
>                             gamma_max:float=None, gamma_step:float=None,
>                             path_to_communities:str=None, method:str='molti')

------------------------------------------------------------------------

### continual_multiplex_analysis

>      continual_multiplex_analysis (nodelist:list[str]=None,
>                                    path_to_communities:str=None,
>                                    distmethod:str='hamming', n_jobs:int=1)

------------------------------------------------------------------------

### cmmd

>      cmmd (nodelist:list[str]|None=None, input_layers:list[str]=None,
>            gamma_min:float=None, gamma_max:float=None, gamma_step:float=None,
>            distmethod:str='hamming', method:str='molti', n_jobs:int=1,
>            path_to_communities:str=None)

*Compute CmmD multilayer community trajectory analysis for a set of
given networks.*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>nodelist</td>
<td>list[str] | None</td>
<td>None</td>
<td>A list with the unique nodes that we want to appear in the final
output. If not given,<br>all nodes of the multiplex will be in the final
output (nodelist= NULL)</td>
</tr>
<tr class="even">
<td>input_layers</td>
<td>list</td>
<td>None</td>
<td>A vector of strings containing the paths where the different network
layers are located<br>in the system. Networks should be a two column
file representing the edges of the graph.</td>
</tr>
<tr class="odd">
<td>gamma_min</td>
<td>float</td>
<td>None</td>
<td>The first gamma resolution parameter to use in the different MolTi’s
analysis</td>
</tr>
<tr class="even">
<td>gamma_max</td>
<td>float</td>
<td>None</td>
<td>The last gamma resolution parameter to use in the different MolTi’s
analysis.</td>
</tr>
<tr class="odd">
<td>gamma_step</td>
<td>float</td>
<td>None</td>
<td>The gamma_step of the resolution parameter to use.</td>
</tr>
<tr class="even">
<td>distmethod</td>
<td>str</td>
<td>hamming</td>
<td>A distance method metric to use to compute the trajectories.
Defaults to “hamming” for hamming<br>distance, but accepts any other
metric supplied by scipy.spatial.distance.pdist.</td>
</tr>
<tr class="odd">
<td>method</td>
<td>str</td>
<td>molti</td>
<td></td>
</tr>
<tr class="even">
<td>n_jobs</td>
<td>int</td>
<td>1</td>
<td>The number of n_jobs to use for the computation of the distance
matrix. Defaults to 1.</td>
</tr>
<tr class="odd">
<td>path_to_communities</td>
<td>str</td>
<td>None</td>
<td>The path to save Molti’s output files. Defaults to “Output/”.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>A dictionary containing the following keys:</strong></td>
<td></td>
<td><strong>gene_community_matrix: A matrix where the rows correspond to
the different genes, and the columns to the different community
structures. The values of the matrix are the cluster to which the gene
belongs in the corresponding community structure.<br>l_constant: A
dictionary where the keys are the different community structures, and
the values are the list of genes that belong to that community
structure.<br>distance_matrix: A matrix with the hamming distances
between all pairs of genes.</strong></td>
</tr>
</tbody>
</table>

``` python
# prefix = "../data/bsc_baseline_tiny/"
prefix = "../data/synthetic/"

input_layers = [prefix + x for x in os.listdir(prefix) if x.endswith(".csv")]

for l in input_layers:
    assert Path(l).exists()

cmmd_output = cmmd(nodelist = None,
     input_layers = input_layers,
     gamma_min = 0,
     gamma_max = 30,
     gamma_step = 0.5,
     path_to_communities = "../out/communities/",
     distmethod = "hamming",
     n_jobs = 6)
```

Clean folder that contains the gerated files of the communities:

``` python
CLEAN = False
folder_path = Path("../out/communities/")

if CLEAN:
    for item in os.listdir(folder_path):
        shutil.rmtree(os.path.join(folder_path, item)) if os.path.isdir(os.path.join(folder_path, item)) else os.remove(os.path.join(folder_path, item))
```

Save object to the disk:

``` python
# # save object to file
# path_save = Path("../out/cmmd_pickle/")
# assert path_save.exists()

# # pickle the object
# with open(path_save / "cmmd_output.pkl", 'wb') as handle:
#     pickle.dump(cmmd_output, handle, protocol=pickle.HIGHEST_PROTOCOL)
```

``` python
# def test_cmmd(cmmd:dict, path_save:pathlib.Path|str=Path("../out/cmmd_pickle/cmmd_output.pkl")) -> None:
#     # load the cmmd object
#     with open(path_save, 'rb') as handle:
#         cmmd_old = pickle.load(handle)
#     assert (cmmd["distance_matrix"] == cmmd_old["distance_matrix"]).all()
#     assert (cmmd["gene_community_matrix"] == cmmd_old["gene_community_matrix"]).all()
#     assert cmmd["l_constant"] == cmmd_old["l_constant"]
```

Confirm new and old objects generate the same output:

``` python
cmmd_output.keys()
```

``` python
cmmd_output["distance_matrix"]
```

``` python
for key in cmmd_output.keys():
    print(key)
    print(cmmd_output[key])
    print("*" * 20)
```

``` python
cmmd_output["distance_matrix"].shape
```

``` python
dm = cmmd_output["distance_matrix"]
dm
```

``` python
np.unique(dm)
```

``` python
sns.histplot(cmmd_output["distance_matrix"].flatten(), stat="density");
```

``` python
gcm = cmmd_output["gene_community_matrix"]
gcm
```

``` python
gcm.shape
```

``` python
l_constant = cmmd_output["l_constant"]
type(l_constant)
```

``` python
len(l_constant.keys())
```

``` python
cmmd_output.keys()
```
