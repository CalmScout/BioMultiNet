# Dataset generation


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

There are several approaches to generate data to start work with
multilayer networks:

1.  Generate synthetic dataset
2.  Generate subset of existing large dataset for faster iterations
3.  Download and prepare for the work real large dataset

## 0. Imports and paths

``` python
path_data = Path("../data")
path_data.mkdir(exist_ok=True)
```

## 1. Generate synthetic dataset

Create a small multilayer graph for testing purposes.

------------------------------------------------------------------------

### obfuscate_nodes

>      obfuscate_nodes (n_nodes:int, str_len:int=10)

*Maps nodes from range \[0, n_nodes) to unique random strings of length
str_len. All upper case letters and digits are used, starts with a
letter.*

``` python
d = obfuscate_nodes(n_nodes=10)
d
```

    {0: 'TDM64O28SE',
     1: 'RM5SDNA1OK',
     2: 'QR899VV1BX',
     3: 'KY0DL1ZA12',
     4: 'LMJ97OFR4T',
     5: 'SF9IFSZ6FW',
     6: 'NPDRTOOGCO',
     7: 'Q2VY4N4GSM',
     8: 'XLRB0CDJQV',
     9: 'ZQDUOFQK5Z'}

The following is a thin wrapper around the random graph generators from
[networkx](https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.random_graphs)
package.

------------------------------------------------------------------------

### create_random_graph

>      create_random_graph (generator:<built-infunctioncallable>,
>                           obfuscate:bool=True, **kwargs)

\*Thin wrapper around networkx’s random graph generator

Args: generator (callable): networkx’s random graph generator
\*\*kwargs: passed to generator Example: \>\>\> G =
create_random_graph(nx.erdos_renyi_graph, n=10, p=0.6, directed=False)\*

``` python
G = create_random_graph(nx.erdos_renyi_graph, n=10, p=0.6, directed=False)
```

``` python
G.nodes()
```

    NodeView(('S6QFO1ZOOD', 'V6F732N51S', 'DZ4QNV6LC6', 'D4POADW5GR', 'O5H4A5JYGS', 'XUB6AWP171', 'H7PL8A6NRT', 'XSA9A9HXBI', 'SF1UYD46BO', 'DQC077RYGA'))

Create random graph and write it to the disk:

------------------------------------------------------------------------

### create_and_save_random_graph

>      create_and_save_random_graph (generator:<built-infunctioncallable>,
>                                    label:str, path_to:str|pathlib.Path,
>                                    obfuscate:bool=True, **kwargs)

\*Creates a random graph and saves it to path_to.

Args: generator (callable): networkx’s random graph generator obfuscate
(bool, optional): if true, obfuscates node names. Defaults to True.
path_to (str|Path, optional): path to save the graph. Defaults to None.

Example: \>\>\> create_random_graph_and_save(nx.erdos_renyi_graph, n=10,
p=0.6, directed=False, path_to=path_data / ‘synthetic’ / ‘1.csv’)\*

Create three layers. For experiments with CmmD algorithm we need at
least several hundreds of nodes to see the difference in the clustering
with a variety of *γ* values:

``` python
path_dir_to = path_data / 'synthetic'
path_dir_to.mkdir(exist_ok=True)
```

``` python
n, p, label = 300, 0.6, "first"
create_and_save_random_graph(nx.erdos_renyi_graph, label, path_dir_to / '1.csv', n=n, p=p)

n, p, label = 500, 0.4, "second"
create_and_save_random_graph(nx.erdos_renyi_graph, label, path_dir_to / '2.csv', n=n, p=p)

n, p, label = 400, 0.7, "third"
create_and_save_random_graph(nx.erdos_renyi_graph, label, path_dir_to / '3.csv', n=n, p=p)
```

The method above generates obfuscated graph with node labels different
from layer to layer. However, for multilayer community analysis we need
that at least some nodes share labels among layers.
